#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shader_clock : enable
#extension GL_NV_shader_invocation_reorder : enable

#define FLT_EPS 0.00000001
#define CLIP_RADIUS 50.0

#include "host_device_common.h"

layout (set = eGeneralRTX, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = eGeneralRTX, binding = 1, scalar) writeonly restrict buffer ClassicTrainingDataBuffer
{
	ClassicTrainingData vertexData[];
} classicTrainingData;

layout (set = eGeneralRTX, binding = 2, scalar) writeonly restrict buffer ClassicTrainingTargetsBuffer
{
	vec3 targets[];
} classicTrainingTargets;

layout (set = eGeneralRTX, binding = 3, scalar) buffer ClassicSharedBuffer
{
	uint nextAvailable;
} classicSharedBuffer;

layout (set = eGeneralRTX, binding = 4, scalar) writeonly restrict buffer ClassicQueryDataBuffer
{
	ClassicTrainingData queryData[];
} classicQueryBuffer;



layout (set = eGeneralRTX, binding = 5, scalar) writeonly restrict buffer DiffuseTrainingDataBuffer
{
	DiffuseTrainingData vertexData[];
} diffuseTrainingData;

layout (set = eGeneralRTX, binding = 6, scalar) writeonly restrict buffer DiffuseTrainingTargetsBuffer
{
	vec3 targets[];
} diffuseTrainingTargets;

layout (set = eGeneralRTX, binding = 7, scalar) buffer DiffuseSharedBuffer
{
	uint nextAvailable;
} diffuseSharedBuffer;

layout (set = eGeneralRTX, binding = 8, scalar) writeonly restrict buffer DiffuseQueryDataBuffer
{
	DiffuseTrainingData queryData[];
} diffuseQueryBuffer;



layout (set = eGeneralRTX, binding = 9, scalar) writeonly restrict buffer SpecularTrainingDataBuffer
{
	SpecularTrainingData vertexData[];
} specularTrainingData;

layout (set = eGeneralRTX, binding = 10, scalar) writeonly restrict buffer SpecularTrainingTargetsBuffer
{
	vec3 targets[];
} specularTrainingTargets;

layout (set = eGeneralRTX, binding = 11, scalar) buffer SpecularSharedBuffer
{
	uint nextAvailable;
} specularSharedBuffer;

layout (set = eGeneralRTX, binding = 12, scalar) writeonly restrict buffer SpecularQueryDataBuffer
{
	SpecularTrainingData queryData[];
} specularQueryBuffer;

layout (set = eGeneralRTX, binding = 13, scalar) readonly buffer RcResBuffer
{
	vec3 res[];
} rcResBuffer;

layout (set = eGeneralRTX, binding = 14, scalar) readonly buffer DiffRcResBuffer
{
	vec3 res[];
} diffRcResBuffer;

layout (set = eGeneralRTX, binding = 15, scalar) readonly buffer SpecRcResBuffer
{
	vec3 res[];
} specRcResBuffer;


layout (set = ePerFrame, binding = 0, rgba32f) uniform image2D outImage;
layout (set = ePerFrame, binding = 1) uniform sampler2D motionVectors;
layout (set = ePerFrame, binding = 2) uniform sampler2D frameTexture;
layout (set = ePerFrame, binding = 3, rgba32f) uniform image2D positionsImage;
layout (set = ePerFrame, binding = 4) uniform sampler2D prevPositions;


layout (set = eGlobal, binding = 0) uniform CameraBuffer
{
	CameraData camData;
} camSceneData;

layout (set = eObjectData, binding = 0, scalar) readonly buffer ObjectBuffer
{
	ObjectData objects[];
} objectBuffer;

layout (set = eDiffuseTex, binding = 0) uniform sampler2D diffuseTex[];
layout (set = eMetallicTex, binding = 0) uniform sampler2D metallicTex[];
layout (set = eRoughnessTex, binding = 0) uniform sampler2D roughnessTex[];
layout (set = eNormalMap, binding = 0) uniform sampler2D normalMap[];

layout (push_constant) uniform constants
{
	RayPushConstants rayConstants;
};

layout (buffer_reference, scalar) buffer Vertices
{
	Vertex v[];
};
layout (buffer_reference, scalar) buffer Indices
{
	uvec3 i[];
};

layout(location = 0) hitObjectAttributeNV vec3 hitUV;


#include "ray_common.glsl"
#include "sampling.glsl"
#include "hit_properties.glsl"
#include "bsdf.glsl"

layout (location = 0) rayPayloadEXT hitPayload prd;


struct RayData
{
  vec3 origin;
  vec3 direction;
  vec3 weight;

  float roughness;

  ClassicTrainingData vData;
  DiffuseTrainingData dvData;
  SpecularTrainingData svData;
};

vec3 saturate(in vec3 v)
{
	return clamp(v, 0.0, 1.0);
}

uint getTileIndex()
{
	uvec2 ind = uvec2(gl_LaunchIDEXT.x / rayConstants.NRC_TILE_WIDTH, gl_LaunchIDEXT.y / rayConstants.NRC_TILE_WIDTH);

	return gl_LaunchSizeEXT.x * ind.y + ind.x;
}

uint getInTileIndex()
{
	uvec2 ind = uvec2(gl_LaunchIDEXT.x % rayConstants.NRC_TILE_WIDTH, gl_LaunchIDEXT.y % rayConstants.NRC_TILE_WIDTH);

	return rayConstants.NRC_TILE_WIDTH * ind.y + ind.x;
}

uint getTrainingBufferIndex(uint vertexIndex)
{
	return getTileIndex() + vertexIndex;
}

vec3 getRCBufferColor(uint cache)
{
    uint bufferId = uint(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x);

	if (cache == eCacheClassic)
	{
		return rcResBuffer.res[bufferId];
	}

	if (cache == eDiffuse)
	{
		return diffRcResBuffer.res[bufferId];
	}
	
	return specRcResBuffer.res[bufferId];
}

vec3 nrcEncodePosition(in vec3 p)
{
	return ((p + CLIP_RADIUS) / (CLIP_RADIUS * 2.0)) * 2.0 - 1.0;
}

float nrcEncodeRoughness(in float r)
{
	return 1 - exp(-r);
}

void getPrevRadianceAtPos(in vec3 pos, in vec2 frameUV, out bool wasVisible, out vec3 prevRadiance)
{
	vec3 posWsCurr = pos;
	vec3 posWsPrev = pos;

	vec4 screenPosCurr = (camSceneData.camData.viewproj * vec4(posWsCurr, 1));
	screenPosCurr /= screenPosCurr.w;

	vec4 screenPosPrev = (camSceneData.camData.prevViewProj * vec4(posWsPrev, 1));
	screenPosPrev /= screenPosPrev.w;

	vec2 prevUV = screenPosPrev.xy * 0.5 + 0.5;
	vec2 currUV = screenPosCurr.xy * 0.5 + 0.5;
	vec2 motion = prevUV - currUV + vec2(0.5) / vec2(gl_LaunchSizeEXT.xy);

	vec3 oldPosition = texture(prevPositions, frameUV + motion).xyz;

	wasVisible = (length(oldPosition - pos) > 2.5) || (clamp(prevUV, 0.0, 1.0) != prevUV);

	if (wasVisible)
	{
		prevRadiance = texture(frameTexture, frameUV + motion).rgb;
	}
	else
	{
		prevRadiance = vec3(0.0);
	}
}

void queryRadianceCache(in ClassicTrainingData data)
{
	uint id = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;

	classicQueryBuffer.queryData[id] = data;
}

void queryRadianceCache(in DiffuseTrainingData data)
{
	uint id = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;

	diffuseQueryBuffer.queryData[id] = data;
}

void queryRadianceCache(in SpecularTrainingData data)
{
	uint id = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;

	specularQueryBuffer.queryData[id] = data;
}

vec2 toSpherical(in vec3 v)
{
	vec3 norm = normalize(v);
	float theta = atan(length(norm.xy), norm.z);
	float phi = atan(norm.y, norm.x);

	return vec2(theta, phi);
}

vec2 hiresToLowres(ivec2 ipos, vec2 jitterOffset)
{
    vec2 inputSize = vec2(gl_LaunchSizeEXT);
    vec2 outputSize = vec2(gl_LaunchSizeEXT);

    return (vec2(ipos) + vec2(0.5)) * (inputSize / outputSize) - jitterOffset;
}

float getSampleWeight(vec2 delta, float scale)
{
    return clamp(1 - scale * dot(delta, delta), 0, 1);
}

RayData integrateHitPoint(RayData r, HitProperties hp, inout uint seed, out uint vertexType)
{
	vec3 L = vec3(0.0);
	vec3 V = normalize(-r.direction);

	float pdf = 0.0;
	vec3 brdf = vec3(0.0);

	vec3 rayOrigin = hp.worldPos;

	int matID = hp.matID;

	if (prd.depth >= 100)
	{
		return r;
	}

	vec4 albedo = texture(diffuseTex[matID], hp.texCoord);
	float metallic = texture(metallicTex[matID], hp.texCoord).b;
	float roughness = texture(roughnessTex[matID], hp.texCoord).g;

	vec3 emittance = hp.emittance;

	float diffuseProb = 0.5 * (1.0 - metallic);
	float specProb = 1.0 - diffuseProb;

	vec3 T = hp.tangent;
	vec3 B = hp.bitangent;
	vec3 N = hp.normal;

	if (rng(seed) < diffuseProb)
	{
		vertexType = eDiffuse;

		L = sampleHemisphere(seed, T, B, N);

		vec3 H = normalize(L + V);

		float dotNL = dot(N, L);
		float dotNV = dot(N, V);

		brdf = DiffuseBRDF(albedo.rgb, metallic, V, N, L, H, pdf);
		pdf *= diffuseProb;
	}
	else
	{
		vertexType = eSpecular;

		vec3 H = sampleGGX(roughness, seed, T, B, N);
		L = reflect(-V, H);

		brdf = SpecularBRDF(albedo.rgb, metallic, roughness, V, N, L, H, pdf);
		pdf *= specProb;
	}

	ClassicTrainingData vertexTrData;
	vertexTrData.position = nrcEncodePosition(hp.worldPos);
	vertexTrData.direction = toSpherical(V);
	vertexTrData.normal = toSpherical(N);
	vertexTrData.roughness = nrcEncodeRoughness(roughness);
	vertexTrData.diffuseAlbedo = albedo.rgb;
	vertexTrData.specularReflectance = mix(vec3(0.04), albedo.rgb, metallic);
	
	DiffuseTrainingData diffVertexTrData;
	diffVertexTrData.position = nrcEncodePosition(hp.worldPos);
	diffVertexTrData.normal = toSpherical(N);
	diffVertexTrData.diffuseAlbedo = albedo.rgb;

	vec2 frameUV = vec2(gl_LaunchIDEXT.xy) / gl_LaunchSizeEXT.xy;
	bool wasVisible;
	vec3 prevRadiance;
	getPrevRadianceAtPos(hp.worldPos, frameUV, wasVisible, prevRadiance);

	diffVertexTrData.wasVisible = wasVisible;
	diffVertexTrData.prevRadiance = prevRadiance;


	SpecularTrainingData specVertexTrData;
	specVertexTrData.position = nrcEncodePosition(hp.worldPos);
	specVertexTrData.direction = toSpherical(V);
	specVertexTrData.normal = toSpherical(N);
	specVertexTrData.roughness = nrcEncodeRoughness(roughness);
	specVertexTrData.specularReflectance = mix(vec3(0.04), albedo.rgb, metallic);

	r.vData = vertexTrData;
	r.dvData = diffVertexTrData;
	r.svData = specVertexTrData;

	r.origin = rayOrigin;
	r.direction = L;
	r.roughness = roughness;
	prd.hitValue = emittance;
	if (pdf > 0.001)
	{
		r.weight = brdf * abs(dot(N, r.direction)) / pdf;
	}
	else
	{
		r.weight = vec3(0.0);
	}

	return r;
}


void main()
{
	uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, uint(clockARB()));

	float r1 = rng(seed);
	float r2 = rng(seed);

	vec2 subpixelJitter = vec2(r1, r2) - vec2(0.5);

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + subpixelJitter;
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = camSceneData.camData.invView[3];
	vec4 target = camSceneData.camData.invProj * vec4(d.x, d.y, 1, 1);
	vec4 direction = camSceneData.camData.invView * vec4(normalize(target.xyz), 0);

	uint rayFlags = gl_RayFlagsNoneEXT;
	float tMin = 0.001;
	float tMax = 10000.0;

	vec3 targetValues[MAX_BOUNCES_LIMIT + 1];
	uint targetValueIds[MAX_BOUNCES_LIMIT + 1];
	uint vertexTypes[MAX_BOUNCES_LIMIT + 1];

	RayData r;

	prd.hitValue = vec3(0.0);
	prd.depth = 0;
	r.origin = origin.xyz;
	r.direction = direction.xyz;
	r.weight = vec3(0.0);
	prd.hitPosition = origin.xyz + direction.xyz * tMax;
	prd.matID = -1;

	vec3 curWeight = vec3(1.0);
	vec3 hitValue = vec3(0.0);

	vec3 primaryPos = vec3(0.0);

	HitProperties hp;
	hp.matID = -1;

	bool primaryMiss = true;
	int lastTargetId = 0;
	int vertexId = 0;

	float queryRoughness = 1.0;

	float q = -1.0;

	for (; prd.depth < rayConstants.MAX_BOUNCES + 1; ++prd.depth)
	{
		if (prd.depth > 0)
		{
			primaryMiss = false;
		}

		if (rayConstants.USE_SHADER_EXECUTION_REORDERING)
		{
			hitObjectNV hObj;
			hitObjectRecordEmptyNV(hObj);
			hitObjectTraceRayNV(hObj,
								topLevelAS,	       // TLAS
								rayFlags,		   // flags
								0xFF,			   // cull mask
								0,				   // SBT record offset
								0,				   // SBT record stride
								0,				   // miss shader index
								r.origin,	       // ray origin
								tMin,			   // ray min range
								r.direction,       // ray direction
								tMax,			   // ray max range
								0				   // ray payload location
			);
			reorderThreadNV(hObj);
			hitObjectGetAttributesNV(hObj, 0);

			if (hitObjectIsHitNV(hObj))
			{
				int instId = hitObjectGetInstanceCustomIndexNV(hObj);
				int primId = hitObjectGetPrimitiveIndexNV(hObj);
				mat4x3 objectToWorld = hitObjectGetObjectToWorldNV(hObj);
				mat4x3 worldToObject = hitObjectGetWorldToObjectNV(hObj);

				if (primId >= 0 && instId >= 0)
				{
					hp = getHitProperties(instId, primId, objectToWorld, worldToObject, hitUV.xy);
				}
			}
			else
			{
				prd.hitValue = vec3(253.0f / 255.0f, 251.0f / 255.0f, 211.0f / 255.0f) * 5;
				// end path
				prd.depth = 100;
				prd.matID = -1;

				hp.worldPos = vec3(10000.0);
			}
		}
		else
		{
			traceRayEXT(topLevelAS,	   // TLAS
					rayFlags,		   // flags
					0xFF,			   // cull mask
					0,				   // SBT record offset
					0,				   // SBT record stride
					0,				   // miss shader index
					r.origin,	       // ray origin
					tMin,			   // ray min range
					r.direction,       // ray direction
					tMax,			   // ray max range
					0				   // ray payload location
			);

			hp.texCoord = prd.texCoord;
			hp.worldPos = prd.hitPosition;
			hp.tangent = prd.tangent;
			hp.bitangent = prd.bitangent;
			hp.normal = prd.normal;
			hp.emittance = prd.emittance;
			hp.matID = prd.matID;
		}

		hitValue += prd.hitValue * curWeight;

		uint vertexType;
		r = integrateHitPoint(r, hp, seed, vertexType);

		if (prd.depth < 100 && rayConstants.NRC_MODE != eNone)
		{
			if (prd.depth == 0)
			{
				if (rayConstants.NRC_MODE == eClassic)
				{
					queryRadianceCache(r.vData);
				}
				else
				{
					queryRadianceCache(r.svData);
					queryRadianceCache(r.dvData);
				}

				queryRoughness = r.roughness;
			}

			if (getInTileIndex() == rayConstants.trainingPathIndex)
			{
				if (rayConstants.NRC_MODE == eClassic)
				{
					uint curBufferId = atomicAdd(classicSharedBuffer.nextAvailable, 1);
					classicTrainingData.vertexData[curBufferId] = r.vData;
					targetValueIds[vertexId] = curBufferId;
					targetValues[vertexId] = r.weight;

					classicTrainingTargets.targets[curBufferId] = vec3(-1.0);
					lastTargetId = vertexId;
				}
				else if (vertexType == eDiffuse)
				{
					uint curBufferId = atomicAdd(diffuseSharedBuffer.nextAvailable, 1);
					diffuseTrainingData.vertexData[curBufferId] = r.dvData;
					targetValueIds[vertexId] = curBufferId;
					targetValues[vertexId] = r.weight;

					diffuseTrainingTargets.targets[curBufferId] = vec3(-1.0);
					lastTargetId = vertexId;
				}
				else
				{
					uint curBufferId = atomicAdd(specularSharedBuffer.nextAvailable, 1);
					specularTrainingData.vertexData[curBufferId] = r.svData;
					targetValueIds[vertexId] = curBufferId;
					targetValues[vertexId] = r.weight;

					specularTrainingTargets.targets[curBufferId] = vec3(-1.0);
					lastTargetId = vertexId;
				}

				vertexTypes[vertexId] = vertexType;
			}
			else
			{
				prd.depth = 80;
				primaryMiss = false;
			}
		}

		if (prd.depth == 100 && getInTileIndex() == rayConstants.trainingPathIndex && rayConstants.NRC_MODE != eNone)
		{
			targetValues[lastTargetId] *= prd.hitValue;
		}

		curWeight *= r.weight;

		if (prd.depth == 0)
		{
			primaryPos = hp.worldPos;
		}

		++vertexId;
		// Russian roulette path termination
		if (rayConstants.NRC_MODE == eNone && prd.depth > 2 && prd.depth < 80)
		{
			q = max(0.05f, 1.f - max(r.weight.r, max(r.weight.g, r.weight.b)));
			if (rng(seed) < q)
			{
				break;
			}
			curWeight /= (1.0 - q);
		}
	}

	imageStore(positionsImage, ivec2(gl_LaunchIDEXT.xy), vec4(primaryPos, 1.0));

	if (rayConstants.frame > 0 && rayConstants.USE_TEMPORAL_ACCUMULATION)
	{
		vec2 frameUV = vec2(gl_LaunchIDEXT.xy) / gl_LaunchSizeEXT.xy;

		vec2 motion = vec2(0.0);

		float a = 0.1;

		if (rayConstants.USE_MOTION_VECTORS)
		{
			vec3 posWsCurr = primaryPos;
			vec3 posWsPrev = primaryPos;

			vec4 screenPosCurr = (camSceneData.camData.viewproj * vec4(posWsCurr, 1));
			screenPosCurr /= screenPosCurr.w;

			vec4 screenPosPrev = (camSceneData.camData.prevViewProj * vec4(posWsPrev, 1));
			screenPosPrev /= screenPosPrev.w;

			vec2 prevUV = screenPosPrev.xy * 0.5 + 0.5;
			vec2 currUV = screenPosCurr.xy * 0.5 + 0.5;
			motion.xy = prevUV - currUV + vec2(0.5) / vec2(gl_LaunchSizeEXT.xy);

			float uvDiffLength = length(motion);

			vec2 nearestRenderPos = hiresToLowres(ivec2(gl_LaunchIDEXT.xy), subpixelJitter);
			ivec2 intRenderPos = ivec2(round(nearestRenderPos.x), round(nearestRenderPos.y));
			intRenderPos = clamp(intRenderPos, ivec2(0), ivec2(gl_LaunchSizeEXT.x - 1, gl_LaunchSizeEXT.y - 1));

			float motionWeight = smoothstep(0, 1.0, uvDiffLength);
			float sampleWeight = getSampleWeight(nearestRenderPos - intRenderPos, 1.0);

			a = clamp(max(smoothstep(0, 1.0, uvDiffLength), sampleWeight) * 0.1, 0.0, 1.0);

			vec3 oldPosition = texture(prevPositions, frameUV + motion).xyz;

			bool posRejected = length(oldPosition - primaryPos) > 2.5;

			if (clamp(prevUV, 0.0, 1.0) != prevUV || posRejected)
			{
				a = 1.0;
			}
		}
		else
		{
			a = 1.0 / float(rayConstants.frame + 1);
		}

		vec3 oldColor = vec3(0.0);

		if (rayConstants.USE_MOTION_VECTORS)
		{
			oldColor = texture(frameTexture, frameUV + motion).xyz;
		}
		else
		{
			oldColor = imageLoad(outImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
		}

		if (!primaryMiss)
		{
			vec3 resColor;

			switch (rayConstants.NRC_MODE)
			{
				case eClassic:
					resColor = saturate(getRCBufferColor(eCacheClassic));
					break;
				case eDedicatedTemporalAdaptation:
					resColor = saturate(mix(getRCBufferColor(eSpecular), getRCBufferColor(eDiffuse), queryRoughness));
					break;
				default:
					resColor = mix(oldColor, hitValue, a);
					break;
			}

			imageStore(outImage, ivec2(gl_LaunchIDEXT.xy), vec4(resColor, 1.0));
		}
		else
		{
			imageStore(outImage, ivec2(gl_LaunchIDEXT.xy), vec4(prd.hitValue, 1.0));
		}
	}
	else
	{
		vec3 resColor;

		switch (rayConstants.NRC_MODE)
		{
			case eClassic:
				resColor = saturate(getRCBufferColor(eCacheClassic));
				break;
			case eDedicatedTemporalAdaptation:
				resColor = saturate(mix(getRCBufferColor(eSpecular), getRCBufferColor(eDiffuse), queryRoughness));
				break;
			default:
				resColor = hitValue;
				break;
		}

		imageStore(outImage, ivec2(gl_LaunchIDEXT.xy), vec4(resColor, 1.0));
	}

	if (getInTileIndex() == rayConstants.trainingPathIndex && rayConstants.NRC_MODE != eNone)
	{
		for (int i = lastTargetId; i >= 0; --i)
		{
			if (i < lastTargetId)
			{
				targetValues[i] *= targetValues[i + 1];
			}
			if (rayConstants.NRC_MODE == eClassic)
			{
				classicTrainingTargets.targets[targetValueIds[i]] = targetValues[i];
			}
			else if (vertexTypes[i] == eDiffuse)
			{
				diffuseTrainingTargets.targets[targetValueIds[i]] = targetValues[i];
			}
			else
			{
				specularTrainingTargets.targets[targetValueIds[i]] = targetValues[i];
			}
		}
	}
}