#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shader_clock : enable
#extension GL_NV_shader_invocation_reorder : enable

#include "host_device_common.h"
#include "common.glsl"

layout (set = eGeneralRTX, binding = 0) uniform accelerationStructureEXT TLAS;

layout (set = ePerFrame, binding = 0, rgba32f) uniform image2D outImage;
layout (set = ePerFrame, binding = 1) uniform sampler2D frameTexture;
layout (set = ePerFrame, binding = 2, rgba32f) uniform image2D positionsImage;
layout (set = ePerFrame, binding = 3) uniform sampler2D prevPositions;

layout (set = eGlobal, binding = 0) uniform CameraBuffer
{
	CameraDataGPU CAM_DATA;
	LightingData LIGHTING_DATA;
};

layout (set = eObjectData, binding = 0, scalar) readonly buffer ObjectBuffer
{
	ObjectData objects[];
} objectBuffer;

layout (set = eDiffuseTex, binding = 0) uniform sampler2D diffuseTex[];
layout (set = eMetallicTex, binding = 0) uniform sampler2D metallicTex[];
layout (set = eRoughnessTex, binding = 0) uniform sampler2D roughnessTex[];
layout (set = eNormalMap, binding = 0) uniform sampler2D normalMap[];

layout (set = eSkybox, binding = 0) uniform samplerCube skyboxSampler;

layout (push_constant) uniform constants
{
	RayPushConstants rayConstants;
};

layout (buffer_reference, scalar) buffer Vertices
{
	Vertex VERTICES[];
};

layout (buffer_reference, scalar) buffer Indices
{
	uvec3 INDICES[];
};

layout(location = 0) hitObjectAttributeNV vec3 hitUV;


#include "ray_common.glsl"
#include "sampling.glsl"
#include "hit_properties.glsl"
#include "bsdf.glsl"

layout (location = 0) rayPayloadEXT RayPayload rayPayload;

#include "path_tracing_utils.glsl"

struct RayData
{
  vec3 origin;
  vec3 direction;
  vec3 weight;
};


RayData IntegrateHitPoint(RayData ray, HitProperties hitProperties, inout uint seed)
{
	vec3 L = vec3(0.0);
	vec3 V = normalize(-ray.direction);

	float pdf = 0.0;
	vec3 brdf = vec3(0.0);

	vec3 rayOrigin = hitProperties.worldPos;

	int matID = hitProperties.matID;

	if (rayPayload.hasMissed)
	{
		return ray;
	}

	vec4 albedo = texture(diffuseTex[matID], hitProperties.texCoord);
	float metallic = texture(metallicTex[matID], hitProperties.texCoord).b;
	float roughness = texture(roughnessTex[matID], hitProperties.texCoord).g;

	vec3 emittance = hitProperties.emittance;

	float diffuseProb = 0.5 * (1.0 - metallic);
	float specProb = 1.0 - diffuseProb;

	vec3 T = hitProperties.tangent;
	vec3 B = hitProperties.bitangent;
	vec3 N = hitProperties.normal;

	bool isDiffusePath = rng(seed) < diffuseProb;

	if (isDiffusePath)
	{
		L = sampleHemisphere(seed, T, B, N);

		vec3 H = normalize(L + V);

		float dotNL = dot(N, L);
		float dotNV = dot(N, V);

		brdf = DiffuseBRDF(albedo.rgb, metallic, V, N, L, H, pdf);
		pdf *= diffuseProb;
	}
	else
	{
		vec3 H = sampleGGX(roughness, seed, T, B, N);
		L = reflect(-V, H);

		brdf = SpecularBRDF(albedo.rgb, metallic, roughness, V, N, L, H, pdf);
		pdf *= specProb;
	}

	ray.origin = rayOrigin;
	ray.direction = L;

	rayPayload.hitValue = emittance;
	if (pdf > 0.001)
	{
		ray.weight = brdf * max(0.0, dot(N, ray.direction)) / pdf;
	}
	else
	{
		ray.weight = vec3(0.0);
	}

	return ray;
}


void main()
{
	uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, uint(clockARB()));

	float r1 = rng(seed);
	float r2 = rng(seed);

	vec2 subpixelJitter = vec2(r1, r2) - vec2(0.5);

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + subpixelJitter;
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 clipUV = inUV * 2.0 - 1.0;

	vec4 origin = CAM_DATA.invView[3];
	vec4 target = CAM_DATA.invProj * vec4(clipUV.x, clipUV.y, 1, 1);
	vec4 direction = CAM_DATA.invView * vec4(normalize(target.xyz), 0);

	uint rayFlags = gl_RayFlagsNoneEXT;
	float tMin = 0.001;
	float tMax = 10000.0;

	RayData ray;

	rayPayload.hasMissed = false;
	rayPayload.hitValue = vec3(0.0);
	rayPayload.depth = 0;
	ray.origin = origin.xyz;
	ray.direction = direction.xyz;
	ray.weight = vec3(0.0);
	rayPayload.hitPosition = origin.xyz + direction.xyz * tMax;
	rayPayload.matID = -1;

	vec3 curWeight = vec3(1.0);
	vec3 hitValue = vec3(0.0);

	vec3 primaryHitPos = vec3(0.0);

	HitProperties hitProperties;
	InitHitProperties(hitProperties);

	bool primaryMiss = true;
	float terminationProbability = 0.0;

	for (; !rayPayload.hasMissed && rayPayload.depth < rayConstants.MAX_BOUNCES + 1; ++rayPayload.depth)
	{
		if (rayPayload.depth > 0)
		{
			primaryMiss = false;
		}

		hitProperties = TraceRay(ray.origin, ray.direction, tMin, tMax, rayFlags);

		ray = IntegrateHitPoint(ray, hitProperties, seed);

		hitValue += rayPayload.hitValue * curWeight;
		curWeight *= ray.weight;

		if (rayPayload.depth == 0)
		{
			primaryHitPos = hitProperties.worldPos;
		}

		// Russian roulette path termination
		if (rayPayload.depth > 2)
		{
			terminationProbability = max(0.05f, 1.f - max(ray.weight.r, max(ray.weight.g, ray.weight.b)));
			if (rng(seed) < terminationProbability)
			{
				break;
			}
			curWeight /= (1.0 - terminationProbability);
		}
	}

	imageStore(positionsImage, ivec2(gl_LaunchIDEXT.xy), vec4(primaryHitPos, 1.0));

	vec3 resValue = hitValue;

	if (rayConstants.frame > 0 && rayConstants.USE_TEMPORAL_ACCUMULATION)
	{
		vec2 frameUV = vec2(gl_LaunchIDEXT.xy) / gl_LaunchSizeEXT.xy;

		vec2 motion = vec2(0.0);

		float currentFrameWeight = 0.1;

		if (rayConstants.USE_MOTION_VECTORS)
		{
			currentFrameWeight = CalculateCurrentFrameWeightAndMotion(primaryHitPos, frameUV, subpixelJitter, motion);
		}
		else
		{
			currentFrameWeight = 1.0 / float(rayConstants.frame + 1);
		}

		vec3 oldColor = vec3(0.0);

		if (rayConstants.USE_MOTION_VECTORS)
		{
			oldColor = texture(frameTexture, frameUV + motion).xyz;
		}
		else
		{
			oldColor = imageLoad(outImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
		}

		if (primaryMiss)
		{
			resValue = rayPayload.hitValue;
		}
		else
		{
			resValue = mix(oldColor, hitValue, currentFrameWeight);
		}
	}

	imageStore(outImage, ivec2(gl_LaunchIDEXT.xy), vec4(resValue, 1.0));
}
